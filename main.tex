\documentclass[10pt,journal,compsoc]{IEEEtran}
\usepackage[UKenglish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{url}
\usepackage{listings}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{attrib}

\hyphenation{op-tical net-works semi-conduc-tor}

% Styling commands
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tit}[1]{\textit{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}

% Document-specific commands
\newcommand{\ws}{WebSocket}
\newcommand{\term}[1]{\tit{#1}}


\begin{document}

\author{\IEEEauthorblockN{Thibault Gérondal, Michaël Heraly}}

\title{Survey paper: \ws}

\date{Tuesday, 27 Oct 2015}

\maketitle
\IEEEpeerreviewmaketitle


%\IEEEdisplaynontitleabstractindextext

\begin{abstract}
The most common way to get information and to communicate through the internet is via the Hypertext Transfer Protocol (HTTP).
Over time, the shared media sent through this communication system have evolved, from text to images and videos.
Interactions between clients and servers have evolved as well.
We went from passive customers who receive information to active clients wanting to communicate in real-time.
The original HTTP was never designed to achieve those needs.
The market found some tricks to bypass these limitations.
However, the HTML5 initiative introduced a real solution to this problem : \ws{}.
This solution brings sockets to the web, so full-duplex communications can be established between clients and servers.
% This paper is only bullshit, but let's try to sell it.

In this survey paper, we describe the older techniques that were used to achieve a full-duplex communication before describing the \ws{} protocol itself.
Then, we explore some experiments about how \ws{} is efficient compared to these older methods.
Finally, a point is dedicated to the security issues of \ws.
\end{abstract}


\section{Introduction}

The Hypertext Transfer Protocol (HTTP) is a stateless request-response protocol in the server-client computing model.
The client submits an HTTP request message and the server provides a response (HTML files, images, etc.).
With the growing popularity of the web, the number of web applications has risen significantly, and the need of interactivity between the client and the server is increasing.
In the original HTTP specifications, interactivity was only possible by loading an entire page in order to upload information to the server or to receive new information from the server.
New features to web browsers have arisen in order to successfully add interactivity without (re)loading pages.
Among these, two Javascript API were implemented successively in web \mbox{browsers :} XMLHttpRequest and \ws.


\section{XMLHttpRequest}
\label{XHR}
% Note: real-time interactivity?
One of the first and most used solutions to add real-time interactivity is the XMLHttpRequest (XHR) Object which is a Javascript API that permits the browser to send an HTTP request from a resource to a distant server.
Despite the name of this API, the fetched resource does not have to be an XML file.
In fact, JSON (JavaScript Object Notation) is generally used as it is easier to parse in Javascript \cite{collinalatency}.
This technique is great to send data to the server but not for receiving new data.
If the client wants to keep the information up to date from the server, it will have to poll the server periodically.
This behavior generates a lot of overhead as each request and response will have a full HTTP header and a lot of these requests might return no new data. This technique thus proves to be quite ineffective.

\subsection{The long polling version}

The XHR long polling exploits a loophole inside the \mbox{HTTP/1.1} specifications.
After receiving a HTTP request, a web server is not required to respond immediately, it can defer the reply for a few instants \cite{collinalatency}.
With this technique, the client does not have to poll periodically the server as the web server holds the HTTP request open until it has new data to send to the client, or a timeout expires.
This reduces the amount of useless data transfers and improves the update delay.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\linewidth]{poll_vs_lpoll}
  \caption{periodic polling (left) versus long polling (right) (from \cite{HighPerfBrowserNetworking:polling})}
  \label{poll_vs_lpoll}
\end{figure}

In Fig.~\ref{poll_vs_lpoll}, on the left, the client periodically polls the server to retrieve updates. This is shown on the figure as the ``polling interval''. When an update occurs on the server side, the client has to wait the next polling to be aware of it. On the right, with long polling, the server keeps the connection open until the update occurs. The periodic polling introduces a delay that long polling can avoid. Also, the first polling of the periodic polling is superfluous as it generates data on the network for no real new input.

\section{\ws{} protocol}
The \ws{} protocol was standardized by the IETF as RFC 6455 in 2011 \cite{rfc6455}.
This protocol was designed to bring bidirectional, message-oriented streaming of texts and binary data between web browsers and web servers.

As it was designed for the Web, this protocol copes with existing HTTP infrastructure, which means working over HTTP ports 80 and 443.
As the \ws{} protocol is backward compatible with the existing Web infrastructure, it inherits from all its benefits.
First of all, web browsers support the technology natively, including an origin-based security model. % Expliquer dans une section sécurité ?
The Web infrastructure provides URL-based endpoints, which allows to run multiple services on a single TCP port.
It also removes the length limits imposed by plain TCP protocol.
Finally, it allows the traversal of proxies and firewalls.

The \ws{} protocol remains a fully functional protocol that can be used outside the browser.

\subsection{The \ws{} header}

The \ws{} frame structure is shown in Figure \ref{fig:websocket_frame}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{websocket_frame.png}
    \caption{\ws{} frame structure (from \cite{HighPerfBrowserNetworking:websocket})}
    \label{fig:websocket_frame}
\end{figure}

The \ws{} frame structure is composed of different parts \cite{HighPerfBrowserNetworking:websocket} \cite{performanceEvaluationOfWebsocketProtocol} :
\begin{LaTeXdescription}    % 'description' environment doesn't display well for IEEEtran
    \item[FIN] indicates whether the frame is a final fragment of a message.
    \item[Opcode] indicates the type of the payload data: binary, textual, or protocol-level signaling (e.g. \ttt{close}, \ttt{ping}, \ttt{pong}).
    \item[Mask] indicates whether the payload data is obfuscated (only for messages sent from the client to the server).
    \item[Length] indicates the payload length. If this value is between 0 and 125, this is the actual length.
                    If it is set to 126, the next 2 bytes represent a 16-bit unsigned integer indicating the frame length.
                    If it is set to 127, the next 8 bytes represent a 64-bit unsigned integer indicating the frame length.
    \item[Masking key] is used to disable unwanted payload processed by network intermediaries, like HTTP proxies \cite{performanceEvaluationOfWebsocketProtocol}.
                    This part is omitted in server-originated frames, as the masking is not necessary.
    \item[Payload] corresponds to the application data, or custom data if the client and server use a protocol extension.
\end{LaTeXdescription}



%\section{\ws{} Javascript API}
%The \ws{} Javascript API is being standardized by the World Wide Web Consortium (W3C).


\subsection{The \ws{} handshake}
\label{handshake}
The \ws{} protocol is an application-level protocol built on top of TCP \cite{rfc6455}.
It enables bidirectional data transport in Web sessions.
The \ws{} protocol can be used as a Web-based near real-time communication channel.

As the \ws{} is a TCP-based protocol, it needs a TCP connection to be established between the client and the server before any \ws-based interaction can be performed.
As shown on figure \ref{fig:websocket_connection}, the first step is to create a TCP connection, whose handshaking needs three messages between the client and the server (three-way handshake).
At this point, both have access to the plain TCP protocol and they can send application-specific data to each other.
As designed to cope with existing HTTP infrastructure, the client is going to use HTTP to negociate a switch from regular HTTP to the \ws{} protocol for the rest of the session.
For doing this, the \ws{} protocol is using the HTTP/1.1 Upgrade header in the request message.
This header was designed for allowing a client to upgrade from unsecure connection to a secure TLS connection.
\ws{} has extended the HTTP Upgrade flow with custom WebSocket headers to perform the negotiation \cite{HighPerfBrowserNetworking:websocket}.
The client also offers a version of the \ws{} protocol to be used.
If the server supports the \ws{} protocol, it replies with an HTTP response with the \ttt{101 Switching Protocols} status code.
From that point, the HTTP-based communication is finished.
The connection can then be used as a two-way communication channel where the client and the server can exchange \ws{} messages.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{websocket_tcp_diagram.png}
    \caption{\ws-over-TCP sequence diagram (from \cite{performanceEvaluationOfWebsocketProtocol})}
    \label{fig:websocket_connection}
\end{figure}


\subsection{Presentation}

\subsection{Concrete usage}

\section{Performance of WebSocket}

As we have seen in section~\ref{handshake}, establishing a \ws{} session requires at least five messages.
Making the establishment of a \ws{} connection to take 3.7 times longer than a TCP connection \cite{performanceEvaluationOfWebsocketProtocol}. 

As seen in section~\ref{XHR}, XHR and XHR long polling were the two common used methods to simulate a full-duplex connection.
To determine whether WebSocket outperforms these, we are going to inspect the latency and the throughput of each of these techniques.
Plus, we are going to see how good \ws{} is doing compared to TCP.

\subsection{Comparing the latency}

The experimentation in  compares \ws{}, XHR and XHR long polling with different latency in the underlying link.

In \cite{communicationAndDIsplayingRealTimeDataWithWebSocket}, they propose an experiment to measure the latency induced by the use of WebSockets compared to XHR and XHR long polling.
The server receives weather information every 250 ms from a wind sensor and serves it via several ways (WS, XHR and XHR LP).
To compare the latency, clients and server are synchronized.

In the figure~\ref{fig:comdisp}, three interesting communication behavior are represented.
Figure~\ref{fig:comdisp}a illustrates the \ws{} protocol behavior once it has successfully established the socket connection. Each time the server receives a measurement from the sensor, the server can immediately sends the mesurement to the client.
Figure~\ref{fig:comdisp}b illustrates the XHR long polling behavior with an underlying latency low enough ($< 125 $ms, which corresponds to half the $250$ms observation rate) for the client to establish a poll request that the server will keep until it receives new measurement from the sensor.
Figure~\ref{fig:comdisp}c illustrates the XHR long polling behavior with an underlying latency higher than $125$ms.
The client first polls the server, the request arrives at the server before or at exact time a measurement is available.
As a measurement is available, the server sends the sensor message immediately, which close the connection.
Thus, when the server receives a new poll request from the client, at least one sensor be in the client's queue.
The observed latency is greater than the underlying link.

The long polling is a viable situation as long as the underlying latency is less than half the data measurement rate.
In the situation (a) and (b) of the figure~\ref{fig:comdisp}, the observed latency is the underlying latency.
Meaning that XHR long polling can performs as good as \ws{}.


\begin{figure*}[!t]
    \centering
    \includegraphics[width=\textwidth]{comdisp.png}
    \caption{Communication behavior in three situations. (a) is using \ws{}; (b) is using long polling with a low underlying latency; (c) is using long polling with a latency greater than half the data measurement rate. Measurements occur at a constant rate of one every $M$ ms. (from \cite{communicationAndDIsplayingRealTimeDataWithWebSocket})}
    \label{fig:comdisp}
\end{figure*}




\subsection{Comparison with AJAX solutions}

\subsection{Behavior depending on the environment}



\section{Security}

\subsection{CORS}

\subsection{Proxies}



\section{Conclusion}

In this paper, we covered the different solutions that were used prior to the \ws{}.
These include HTTP polling and HTTP long-polling.
Then, we introduced the \ws{}, which is composed by the \ws{} JavaScript API and the underlying \ws{} protocol.
We saw that the \ws{} protocol was based on TCP.
We presented how two hosts could connect to each other to create a \ws{} session.
We also exposed the \ws{} header to explain the \ws{} frame structure.
We ended the paper by comparing the technology with the prior solutions, with a focus on the throughput and the latency.
It turns out that the \ws{} causes a slightly lower performance compared to the plain TCP protocol.
It causes some overhead and has a higher latency than a plain TCP connection.
However, it is still better than the alternative solutions, as HTTP polling and HTTP long-polling.
The overhead caused by the \ws{} is negligible for practical use, and for situations where a lot of data are sent between the client and the server, the cost of the initial HTTP handshaking is amortized by the large number of payload transfers.

Finally, the \ws{} protocol is a useful addition to the Web, which brings a full-duplex communication that is more efficient than the other solutions thwhichat try to simulate an equivalent behaviour in HTTP-based applications.


\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


\bibliographystyle{IEEEtran}
\bibliography{bibi}


\end{document}
\documentclass[10pt,journal,compsoc]{IEEEtran}
\usepackage[UKenglish]{babel}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{url}
\usepackage{listings}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{framed}
\usepackage{attrib}

\hyphenation{op-tical net-works semi-conduc-tor}

% Styling commands
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tit}[1]{\textit{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}

% Document-specific commands
\newcommand{\ws}{WebSocket}
\newcommand{\term}[1]{\tit{#1}}


\begin{document}

\author{\IEEEauthorblockN{Thibault Gérondal, Michaël Heraly}}

\title{Survey paper: \ws}

\date{Tuesday, 27 Oct 2015}

\maketitle
\IEEEpeerreviewmaketitle


%\IEEEdisplaynontitleabstractindextext

\begin{abstract}
The most common way to get some information and communicate through the internet is via the Hypertext Transfer Protocol (HTTP).
Over time, the shared media sent through this communication system have evolved.
It started from text to images and videos.
And interactions between clients and servers have evolved too.
We went from passive customers who receives informations to active clients that wants to communicate in real-time.
The original HTTP was never designed to achieve those needs.
The market found some tricks to bypass these limitations.
But the HTML5 initiative introduced a real solution to this problem : \ws{}.
This solution brings socket to the web, so a full-duplex communication can be established between the clients and the server.
% This paper is only bullshit, but let's try to sell it.

In this survey paper, we describe the older techniques that were used to achieve a full-duplex communication before describing the \ws{} protocol itself.
Then, we explore some experiments about how \ws{} is efficient compared to these older techniques.
Finally, a point is dedicated to the security issues of \ws.
\end{abstract}


\section{Introduction}

The Hypertext Transfer Protocol (HTTP) is a stateless request-response protocol in the server-client computing model.
The client submits an HTTP request message and the server provides a response (HTML files, images, etc.).
With the growing the popularity of the web, the number of web applications has risen significantly.
And the need of interactivity between the client and the server was increasing.
In the original HTTP specifications, interactivity was only possible by loading an entire page in order to upload informations to the server or to receive new informations from the server.
But new features to web browsers have arisen in order to successfully add interactivity without (re)loading pages.
Among these, two Javascript API were implemented successively in web \mbox{browsers :} XMLHttpRequest and \ws.


\section{XMLHttpRequest}

% Note: real-time interactivity?
One of the first and most used solution to add real-time interactivity is the XMLHttpRequest (XHR) Object which is a Javascript API that permits the browser to send a HTTP request for a resource to a distant server.
Despite the name of this API, the fetched resource don't have to be an XML file.
In fact, JSON (JavaScript Object Notation) is generally used as it is more easy to parse in Javascript \cite{collinalatency}.
This technique is great to send data to the server but not for receiving new data.
If the client wants to keep the information up to date from the server, it will have to poll the server periodically.
This behavior generates a lot of overhead as each request and response will have a full HTTP header and a lot of these requests might return no new data, so this technique is quite ineffective.

\subsection{The long polling version}

The XHR long polling exploits a loophole inside the \mbox{HTTP/1.1} specifications.
After receiving a HTTP request, a web server is not required to respond immediately, it can defer few instant the reply \cite{collinalatency}.
With this technique, the client doesn't have to poll periodically the server as the web server holds the HTTP request open until it has new data to send to the client, or a timeout expires.
This reduces the amount of useless data transfers and improve the update delay.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=\linewidth]{poll_vs_lpoll}
  \caption{periodic polling (left) versus long polling (right) (from \cite{HighPerfBrowserNetworking:polling})}
  \label{poll_vs_lpoll}
\end{figure}

In Fig.~\ref{poll_vs_lpoll}, on the left, the client periodically polls every ``polling interval'' the server to retrieve updates. When an update occurs on the server side, the client have to wait the next polling to be aware of it. On the right, with long polling, the server keeps open the connection until the update occurs. The periodic polling introduces a delay that long polling can avoid. Also, the first polling of the periodic polling is superfluous as it generates data on the network for no real new input.

\section{\ws{} protocol}
The \ws{} protocol was standardized by the IETF as RFC 6455 in 2011 \cite{rfc6455}.
This protocol was designed to bring bidirectional, message-oriented streaming of text and binary data between web browsers and web servers.

As it was designed for the Web, this protocol copes with existing HTTP infrastructure, which means to work over HTTP ports 80 and 443.
As the \ws{} protocol is backward compatible with the existing Web infrastructure, it inherits from all its benefits.
First of all, the Web browsers support the technology natively, including an origin-based security model.
The Web infrastructure provides URL-based endpoints, which allows to run multiple services on a single TCP port.
It also removes the length limits imposed by plain TCP protocol.
Finally, it allows the traversal of proxies and firewalls.

The \ws{} protocol remains a fully functional protocol that can be used outside the browser.


\subsection{The \ws{} header}

The \ws{} frame structure is shown in Figure \ref{fig:websocket_frame}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{websocket_frame.png}
    \caption{\ws{} frame structure (from \cite{HighPerfBrowserNetworking:websocket})}
    \label{fig:websocket_frame}
\end{figure}

The \ws{} frame structure is composed of different parts \cite{HighPerfBrowserNetworking:websocket} \cite{performanceEvaluationOfWebsocketProtocol} :
\begin{LaTeXdescription}    % 'description' environment doesn't display well for IEEEtran
    \item[FIN] indicates whether the frame is a final fragment of a message.
    \item[Opcode] indicates the type of the payload data: binary, textual, or protocol-level signaling (e.g. \ttt{close}, \ttt{ping}, \ttt{pong}).
    \item[Mask] indicates whether the payload data is obfuscated (only for messages sent from the client to the server).
    \item[Length] indicates the payload length. If this value is between 0 and 125, this is the actual length.
                    If it is set to 126, the next 2 bytes represent a 16-bit unsigned integer indicating the frame length.
                    If it is set to 127, the next 8 bytes represent a 64-bit unsigned integer indicating the frame length.
    \item[Masking key] used to disable unwanted payload processing by network intermediaries, like HTTP proxies \cite{performanceEvaluationOfWebsocketProtocol}.
                    This part is omitted in server-originated frames, as the masking is not necessary.
    \item[Payload] corresponds to the application data, or custom data if the client and server use a protocol extension.
\end{LaTeXdescription}



\section{\ws{} Javascript API}
The \ws{} Javascript API is being standardized by the World Wide Web Consortium (W3C).


\section{Performance of WebSocket}

Establishing a \ws{} session takes 3.7 times longer than establishing a TCP connection \cite{performanceEvaluationOfWebsocketProtocol}.


\section{\ws{} protocol}

The \ws{} protocol is an application-level protocol built on top of TCP \cite{rfc6455}.
It enables bidirectional data transport in Web sessions.
The \ws{} protocol can be used as a Web-based near real-time communication channel.

As the \ws{} is a TCP-based protocol, it needs a TCP connection to be established between the client and the server before any \ws-based interaction can be performed.
As shown on figure \ref{fig:websocket_connection}, the first step is to create a TCP connection, whose handshaking needs three messages between the client and the server.
At this point, both have access to the plain TCP protocol and they can send aplication-specific data to each other.
To switch from regular HTTP to the \ws{} protocol for the rest of the session, the client sends a \term{\ws{} Upgrade Request} to the server.
This is made by extending the HTTP Upgrade flow with custom WebSocket headers to perform the negotiation \cite{HighPerfBrowserNetworking:websocket}.
The client also proposes a version of the \ws{} protocol to be used.
If the server supports the \ws{} protocol, it replies with an HTTP response with the \ttt{101 Switching Protocols} status code.
From that point, the HTTP-based communication is finished.
The connection can then be used as a two-way communication channel where the client and the server can exchange \ws{} messages.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{websocket_tcp_diagram.png}
    \caption{\ws-over-TCP sequence diagram (from \cite{performanceEvaluationOfWebsocketProtocol})}
    \label{fig:websocket_connection}
\end{figure}


\subsection{Presentation}

\subsection{Concrete usage}



\section{Performance of \ws}

\subsection{Comparison with AJAX solutions}

\subsection{Behavior depending on the environment}



\section{Security}

\subsection{CORS}

\subsection{Proxies}



\section{Conclusion}

In this paper, we covered the different solutions that were used prior to the \ws{}.
These include HTTP polling and HTTP long-polling.
Then, we introduced the \ws{}, which is composed by the \ws{} JavaScript API and the underlying \ws{} protocol.
We saw that the \ws{} protocol was based on TCP.
We presented how two hosts could connect to each other to create a \ws{} session.
We also exposed the \ws{} header to explain the \ws{} frame structure.
We ended the paper by comparing the technology with the prior solutions, with a focus on the throughput and the latency.
It turns out the \ws{} causes a slightly lower performance compared to the plain TCP protocol.
It causes some overhead and has a higher latency than a plain TCP connection.
But it is still better than the alternative solutions, as HTTP polling and HTTP long-polling.
The overhead caused by the \ws{} is negligible for practical use, and for situations where a lot of data are sent between the client and the server, the cost of the initial HTTP handshaking is amortized by the large number of payload transfers.

Finally, the \ws{} protocol is a useful addition to the Web which brings a full-duplex communication that is more efficient than the other solutions that try to simulate an equivalent behaviour in HTTP-based applications.


\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


\bibliographystyle{IEEEtran}
\bibliography{bibi}


\end{document}
